import type { NextApiRequest, NextApiResponse } from "next";
import Stripe from "stripe";
import { buffer } from "micro";
import { createClient } from "@supabase/supabase-js";

export const config = { api: { bodyParser: false } };

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });
const supabase = createClient(
process.env.NEXT_PUBLIC_SUPABASE_URL!,
process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
if (req.method !== "POST") return res.status(405).send("Method not allowed");

const sig = req.headers["stripe-signature"] as string;
const buf = await buffer(req);

let event: Stripe.Event;
try {
event = stripe.webhooks.constructEvent(buf, sig, process.env.STRIPE_WEBHOOK_SECRET!);
} catch (err: any) {
return res.status(400).send(`Webhook Error: ${err.message}`);
}

try {
switch (event.type) {
case "checkout.session.completed": {
const session = event.data.object as Stripe.Checkout.Session;
const userId = (session.metadata?.supabase_user_id || session.client_reference_id) as string;
if (userId) {
await supabase.from("profiles").update({ tier: "platinum" }).eq("id", userId);
}
break;
}
case "customer.subscription.updated":
case "customer.subscription.deleted": {
const sub = event.data.object as Stripe.Subscription;
const customerId = sub.customer as string;
const active =
sub.status === "active" || sub.status === "trialing" || sub.status === "past_due";
await supabase
.from("profiles")
.update({ tier: active ? "platinum" : "free" })
.eq("stripe_customer_id", customerId);
break;
}
}
} catch (e: any) {
return res.status(500).json({ ok: false, error: e.message });
}

res.json({ received: true });
}
